/*
 * This is some sample code used on http://scalac.tumblr.com/ 
 * (c) 2009 u.v.poblotzki
 */
package com.tumblr.scalac.samples

class Cell(g: Long) {
  val genome = g
  
  override def toString = {"Cell[" + this.genome + "]"}
}

/**
 * Uses mutation and genetic algorithms to find optimal solutions given some fitness function. 
 * The method names are inspired by greek mythology. 
 */
class Gaia(k: (Cell, Cell) => List[Cell], a: (Cell) => Long, p: Int) {
  import scala.util.Random

  val klotho = k
  val atropos = a

  private var population = List[Cell]()  
  val random = new Random()
  for (i <- 0 until p) {
    population = new Cell(random.nextLong()) :: population    
  }  
  
  /**
   * Generates a new generation of cells. Half of each population is newly generated by
   * using the "klotho" function.
   */
  def tick() {
    this.population = shuffle(this.population.sort(atropos(_) < atropos(_)).take(this.population.length/2))
    def mate(p:List[Cell]):List[Cell] = p match {
      case c1 :: c2 :: xs => klotho(c1, c2) ::: mate(xs)
      case c1 :: Nil => Nil
      case Nil => Nil
    }
    this.population = this.population ::: mate(this.population)
  }
  
  def shuffle[T](list: List[T]): List[T] = { 
    val buf: Array[T] = list.toArray 
    def swap(i1: Int, i2: Int) { 
      val tmp = buf(i1) 
      buf(i1) = buf(i2) 
      buf(i2) = tmp 
    } 
    for (n <- buf.length to 2 by -1) { 
      val k = random.nextInt(n) 
      swap(n - 1, k) 
    } 
    buf.toList 
  } 
  
}

/**
 * Companion object to Gaia class. Defining some basic test functions. 
 */
object Gaia {
  
  /**
   * Two cells genome is mixed together generation two new cells. There genetic 
   * code is altered by mutation. 
   */
  def genMixerKlotho(mutationRate: Double, c1: Cell, c2: Cell): List[Cell] = {
    def randomMask():Long = {                                     
      def oneOrZero():Long = if (Math.random <= mutationRate) 0 else 1
      var result = oneOrZero
      for (i <- 0 until 63) { 
        result = (result << 1) + oneOrZero
      }
      return result
    }

    val child1 = (c1.genome & 0xAAAAAAAAAAAAAAAAL) | (c2.genome & ~0xAAAAAAAAAAAAAAAAL)
    val child2 = (c2.genome & 0xAAAAAAAAAAAAAAAAL) | (c1.genome & ~0xAAAAAAAAAAAAAAAAL) 
    return List(new Cell((child1 & randomMask) ^ ~randomMask), new Cell((child2 & randomMask) ^ ~randomMask))
  }

  /**
   * Simple fitness function with uses the binary representation of the cells genome 
   */
  def fixedNumerAtropos(targetNumer: Long, cell: Cell): Long = {
    (~(~targetNumer ^ cell.genome)).toBinaryString.replaceAll("0","").length  
  }

  /**
   * Try to find the best solution: atropos(cell) == 0 
   */
  def letThereBeLight(klotho: (Cell, Cell) => List[Cell], atropos: (Cell) => Long, populationCount: Int, maxSteps:Int): Cell = {
    val gaia = new Gaia(klotho, atropos, populationCount)
    for (i <- 0 until maxSteps) {
      gaia.tick
      if (atropos(gaia.population.head) == 0) {
        return gaia.population.head
      }
    }
    return null
  }
  
}

